<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql随笔</title>
    <url>/2024/10/19/Mysql%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h5 id="union-和-union-all的区别"><a href="#union-和-union-all的区别" class="headerlink" title="union 和 union all的区别"></a>union 和 union all的区别</h5><blockquote>
<p>union 会把结果的重复部分压缩，而union all则不会，因此在使用<code>count</code>,<code>avg</code>等函数时要注意使用union all，避免</p>
<p>使用union导致结果压缩而出现错误</p>
</blockquote>
<h5 id="将查询结果返回作为一个表"><a href="#将查询结果返回作为一个表" class="headerlink" title="将查询结果返回作为一个表"></a>将查询结果返回作为一个表</h5><blockquote>
<ul>
<li><p><code>with new_table_name as (select column1,column2,... from table)</code></p>
<p>​	<code>select * from new_table_name</code></p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>select * from (select column1,column2,... from table)new_table_name</code></li>
</ul>
</blockquote>
<h5 id="查找第几大（小）的-数据"><a href="#查找第几大（小）的-数据" class="headerlink" title="查找第几大（小）的 数据"></a>查找第几大（小）的 数据</h5><blockquote>
<p><code>select * from table order by column limit n offset n</code></p>
</blockquote>
<h5 id="distinct-的作用范围"><a href="#distinct-的作用范围" class="headerlink" title="distinct 的作用范围"></a>distinct 的作用范围</h5><blockquote>
<p>以<code>select distinct column1,column2 from table</code>为例，distinct作用是消除重复项，此时每一个项为（column1_a,column2_b），因此作用范围是column1,column2</p>
</blockquote>
]]></content>
      <categories>
        <category>“&quot;运维&quot;</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>笔记</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与指针</title>
    <url>/2024/10/18/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h5 id="使用函数计算数组大小"><a href="#使用函数计算数组大小" class="headerlink" title="使用函数计算数组大小"></a>使用函数计算数组大小</h5><blockquote>
<p>指针在win64系统的大小是8字节</p>
</blockquote>
<blockquote>
<p><code>int *p</code>在进行<code>p++</code>操作时，p的值会增加4字节；而如果是<code>double *p</code>在进行<code>p++</code>操作时，p的值会增加8字节，增加的字节数与指针指向的变量类型有关，需要与区别好指针的大小</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">func1</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="built_in">func2</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="built_in">func3</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>sql-ex习题</title>
    <url>/2024/10/18/sql-ex%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><ul>
<li><p>The database scheme consists of four tables:</p>
</li>
<li><p>Product(maker, model, type)</p>
</li>
<li><p>PC(code, model, speed, ram, hd, cd, price)</p>
</li>
<li><p>Laptop(code, model, speed, ram, hd, screen, price)</p>
</li>
<li><p>Printer(code, model, color, type, price)</p>
</li>
</ul>
<blockquote>
<p>The Product table contains data on the maker, model number, and type of product (‘PC’, ‘Laptop’, or ‘Printer’). It is assumed that model numbers in the Product table are unique for all makers and product types. Each personal computer in the PC table is unambiguously identified by a unique code, and is additionally characterized by its model (foreign key referring to the Product table), processor speed (in MHz) – speed field, RAM capacity (in Mb) - ram, hard disk drive capacity (in Gb) – hd, CD-ROM speed (e.g, ‘4x’) - cd, and its price. The Laptop table is similar to the PC table, except that instead of the CD-ROM speed, it contains the screen size (in inches) – screen. For each printer model in the Printer table, its output type (‘y’ for color and ‘n’ for monochrome) – color field, printing technology (‘Laser’, ‘Jet’, or ‘Matrix’) – type, and price are specified.</p>
</blockquote>
<hr>
<p><strong>19.For each maker having models in the Laptop table, find out the average screen size of the laptops he produces.</strong></p>
<p><strong>Result set: maker, average screen size.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,avg(l.screen) from Product p, Laptop l where p.model = l.model group by maker;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>20.Find the makers producing at least three distinct models of PCs.</strong></p>
<p><strong>Result set: maker, number of PC models.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,count(model) from Product where type=&#x27;PC&#x27;group by maker having count(model)&gt;=3;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>21.Find out the maximum PC price for each maker having models in the PC table.</strong> </p>
<p><strong>Result set: maker, maximum price.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,max(price) from Product p1,PC p2 where p1.model=p2.model group by maker;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>22.For each value of PC speed that exceeds 600 MHz, find out the average price of PCs with identical speeds.</strong></p>
<p><strong>Result set: speed, average price.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select speed,avg(price) from PC where PC.speed &gt; 600 group by speed;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>23.Get the makers producing both PCs having a speed of 750 MHz or higher and laptops with a speed of 750 MHz or higher.</strong></p>
<p><strong>Result set: maker</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker from Product where maker in (select distinct maker from Product p1,PC p2 where p1.model=p2.model and speed &gt;= 750) and maker in (select distinct maker from Product p1,Laptop p2 where p1.model=p2.model and speed &gt;=750)</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>24.List the models of any type having the highest price of all products present in the database.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as (select model,price from PC union select model,price from Laptop union select model,price from Printer )` `select model from a where price = (select max(price) from a)</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>26.Find out the average price of PCs and laptops produced by maker A.</strong><br> <strong>Result set: one overall average price for all items.</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as(select price from PC p1 left join Product p2 on p1.model=p2.model where maker=&#x27;A&#x27;</span><br><span class="line">union all</span><br><span class="line">select price from Laptop p1 left join Product p2 on p1.model=p2.model where maker=&#x27;A&#x27;)</span><br><span class="line">select avg(price) from a</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>27.Find out the average hard disk drive capacity of PCs produced by makers who also manufacture printers.</strong><br> <strong>Result set: maker, average HDD capacity.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as(select maker, model from Product where maker in (select distinct maker from Product where type=&#x27;Printer&#x27;))</span><br><span class="line">select  maker ,avg(hd) from PC p1 join a on p1.model=a.model group by maker</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>28.Using Product table, find out the number of makers who produce only one model.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as (select maker,count(model) count from Product group by maker)</span><br><span class="line">select count(maker) from</span><br><span class="line">(select maker from a where count=1)b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp笔记</title>
    <url>/2024/10/19/cpp%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><blockquote>
<ul>
<li><p>含义：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作；而不是像按值传递那样，形参是实参的拷贝</p>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="comment">//函数传参:地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = (*a);</span><br><span class="line">	(*a) = (*b);</span><br><span class="line">	(*b) = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数传参：引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span>&amp; c, <span class="type">int</span>&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = c;</span><br><span class="line">	c = d;</span><br><span class="line">	d = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt;b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">swap1</span>(&amp;a, &amp;b);<span class="comment">//按地址传递</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;swap1后：&quot;</span>  &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">swap2</span>(a, b);<span class="comment">//引用传递</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;swap2后：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>底层原理：</p>
<p>实际上是由一个指针实现的</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层原理相当于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_real</span><span class="params">(<span class="type">int</span> * <span class="type">const</span> a)</span> <span class="comment">//这个指针的值不可变，但是指向的内容可以改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*a)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><blockquote>
<p>含义：static 表示将内容存入静态内存区域，可以修饰变量，函数</p>
<p>当static 在函数内修饰变量，可以将变量的生命周期延长至整个程序结束，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* result1 = <span class="built_in">test1</span>();</span><br><span class="line">	<span class="type">int</span>* result2 = <span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">//打印这些是为了留多点时间给系统回收空间不然执行太快，test2里面的num在执行完函数来不及回收空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; *result1 &lt;&lt; std::endl;  <span class="comment">//结果为0</span></span><br><span class="line">	std::cout &lt;&lt; *result2 &lt;&lt; std::endl;  <span class="comment">//结果为-858993460</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>“&quot;c++&quot;</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客遇到的问题</title>
    <url>/2024/10/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 id="github-显示404"><a href="#github-显示404" class="headerlink" title="github 显示404"></a>github 显示404</h6><blockquote>
<p>在本地已经能够正常显示，但是一部署到GitHub上面却显示404，首先在配置文件中修改配置为</p>
<p>deploy:</p>
<p> type: git</p>
<p> repo: <a href="https://github.com/yanxiao588/yanxiao588.github.io">https://github.com/yanxiao588/yanxiao588.github.io</a></p>
<p> branch: master</p>
<p>master是重点，进入库中，点击setting，点击Default branch修改为master</p>
</blockquote>
<h6 id="下载速度慢"><a href="#下载速度慢" class="headerlink" title="下载速度慢"></a>下载速度慢</h6><blockquote>
<p>可以用淘宝镜像，执行命令：<code>npm config set registry http://registry.npm.taobao.org/</code></p>
<p>切换回官方镜像：<code>npm config set registry http://www.npmjs.org</code></p>
<p>查看镜像：<code>npm get registry</code></p>
</blockquote>
<h6 id="文章在首页正文全部展开，不好找文章"><a href="#文章在首页正文全部展开，不好找文章" class="headerlink" title="文章在首页正文全部展开，不好找文章"></a>文章在首页正文全部展开，不好找文章</h6><blockquote>
<p>在front-matter<code>中添加</code>description，如：</p>
<p>title: 搭建个人博客遇到的问题<br>date: 2024-10-18 03:56:07<br>tags: [“博客”]<br>categories: [“博客”]<br>description: 搭建博客遇到的问题</p>
</blockquote>
<blockquote>
<p>还要设置 excerpt_description: true（默认已经是这么设置了）</p>
</blockquote>
<h6 id="设置本地搜索（localsearch"><a href="#设置本地搜索（localsearch" class="headerlink" title="设置本地搜索（localsearch)"></a>设置本地搜索（localsearch)</h6><blockquote>
<p>在本地正常运行，但是上传到GitHub后显示的和本地不一样，先确保设置之前，执行<code>hexo clean</code>命令</p>
<p>再执行<code>hexo d</code>命令，还是有问题可以多试几次，去GitHub仓库刷新一下</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>空指针和野指针</title>
    <url>/2024/10/18/%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><blockquote>
<p>空指针是指一个指针变量没有被初始化，即没有被赋予具体的内存地址。在程序中，空指针表示指向“空”的内存地址。</p>
</blockquote>
<blockquote>
<p>野指针是指一个指针变量指向一个无效的内存地址，即指针的值不是有效的内存地址。野指针指向的内存可能已经被释放或者尚未分配。</p>
</blockquote>
<h3 id="2-区别："><a href="#2-区别：" class="headerlink" title="2.区别："></a>2.区别：</h3><ul>
<li>空指针是一个<strong>未初始化的指针变量，没有指向具体的内存地址</strong>；而野指针是指<strong>针变量指向一个无效的内存地址</strong>。</li>
<li>空指针可以被赋予有效的内存地址，成为指向有效内存的指针；而野指针无法被赋予有效的内存地址。</li>
<li>空指针可以通过对其赋予有效内存地址来解除为空，使其成为有效指针；而野指针没有办法通过赋值操作变为有效指针，只能通过正确的内存分配和释放操作来避免。</li>
</ul>
<h3 id="3-形成方式"><a href="#3-形成方式" class="headerlink" title="3.形成方式"></a>3.形成方式</h3><ul>
<li><p>空指针的形成</p>
<blockquote>
<ul>
<li><strong>在声明指针变量时，没有给它赋初值</strong>。此时指针变量的值是不确定的，称为空指针。</li>
<li><strong>执行指针变量的值为NULL的赋值操作</strong>，将其设置为空指针。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// p 是一个空指针，指向 &quot;无效&quot; 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p is a null pointer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p points to a valid memory address.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>野指针的形成</li>
</ul>
<blockquote>
<ul>
<li>在<strong>声明指针变量后，没有立即给它赋初值，而是直接使用它进行操作</strong>，此时指针变量的值是不确定的，可能指向任意的内存地址，这种指针就称为野指针。</li>
<li>在<strong>释放了某个内存块后，继续使用指向该内存块的指针变量</strong>，此时指针变量就变成了野指针。因为该内存块已经被释放，再次使用指针变量访问该内存块会引发错误。</li>
<li>在<strong>函数中返回局部变量的指针，因为局部变量会在函数结束后被销毁</strong>，返回的指针就变成了野指针。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> * p1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// p1 指向堆上分配的内存</span></span><br><span class="line">    <span class="type">int</span> * p2 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// p2 也指向堆上分配的内存</span></span><br><span class="line">    *p1 = <span class="number">10</span>;            <span class="comment">// 将 p1 指向的内存赋值为 10</span></span><br><span class="line">    p2 = p1;             <span class="comment">// p2 指向与 p1 相同的内存地址</span></span><br><span class="line">    <span class="keyword">delete</span> p1;           <span class="comment">// 此时 p2 是野指针</span></span><br><span class="line">    p1=<span class="literal">nullptr</span>;</span><br><span class="line">    p2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
